from typing import Sequence, Optional, overload, Union, Tuple, TypeVar

from .tensor import _TensorBase, Tensor, LongTensor, ByteTensor, IntTensor, FloatTensor
from .storage import Storage

T = TypeVar('T', bound='_TensorBase')

import torch.cuda
import torch.nn.functional
import torch.optim
import torch.optim.lr_scheduler

import numpy as np

def cat(seq: Sequence[T], dim: int = 0, out: Optional[T] = None) -> T: ...
def stack(seq: Sequence[T], dim: int = 0, out: Optional[T] = None) -> T: ...
def gather(input: T, dim: int, index: LongTensor, out: Optional[T] = None) -> T: ...

def arange(start: float, end: float, step: float = 1, out: Tensor=None) -> Tensor: ...

def manual_seed(seed: int) -> None: ...
def rand(sizes: Sequence[int], out: Optional[Tensor] = None) -> Tensor: ...

def from_numpy(a: np.ndarray) -> Tensor: ...

@overload
def max(tensor: _TensorBase) -> float: ...
@overload
def max(tensor: _TensorBase, dim: int, keepdim: Optional[bool] = None) -> Tuple[_TensorBase, _TensorBase]: ...
def max(tensor: _TensorBase, dim: Optional[int] = None, keepdim: Optional[bool] = None) -> Union[float, Tuple[_TensorBase, _TensorBase]]: ...

